### TO DO:
- Да направите messenger/discord/teams/slack/whatever чат/група и да ни добавите с Марти
- [GitHub Classroom]()

# Малко теория
## Променливи
>### Инициализация, декларация и дефиниция:
- Декларация е, когато създаваме променлива, без да ѝ присвоим стойност `int myAge;`
- Инициализация е, когато присвояваме на дадена променлива стойност при декларацията `int myAge = 20;`
- Дефиниция е, когато променливата вече е декларирана някъде, но няма зададена стойност и след дадено време решаваме, че ни трябва стойност и я задаваме там.
```c++
{
    int myAge;
    // one eternity later
    myAge = 20;
}
```

>### Преобразуване на променливи:
- Неявно преобразуване: 
```c++
double x = 6.9;
int y = x;
std::cout << y; //Извежда: 6
```
- Явно преобразуване: (тип)(<израз>)
```c++
int x = (int) (6.9 + 6.9);
double y = (double) (123 + 321);
std::cout << x << " " << y; //Извежда: 13 444
```
- Друг вид явно преобразуване:(static_cast<тип>(<променлива> или <израз>))
```c++
int x = static_cast<int>(6.9 + 6.9);
double y = static_cast<double>(123 + 321);
std::cout << x << " " << y; //13 444
```

Когато преобразуваме от `double` в `int`, `int`-ът приема само цялата част на `double`-а.

### [Сравняване на floating point числа](https://www.geeksforgeeks.org/dsa/problem-in-comparing-floating-point-numbers-and-how-to-compare-them-correctly/)


>### Символен тип (char) и ASCII таблица:

- Създаване на променлива от тип **char**: Използваме единични кавички `' '`, защото двойните `" "` са запазени за символни **низове**.
```c++
char symbol = 'A';
```

- На всеки символ от ASCII таблицата съответства цяло число
![ASCII Table](https://www.asciitable.com/asciifull.gif)

## III. Вградени функции и операции с числа
[Приоритет на операторите](https://en.cppreference.com/w/cpp/language/operator_precedence.html)

|         Операция        |               Оператор               |         Пример        |
|:-----------------------:|:------------------------------------:|:---------------------:|
|         Събиране        |                   +                  |          1+2          |
|        Изваждане        |                   -                  |          3-2          |
|        Умножение        |                   *                  |          2*3          |
|   Целочислено деление   |     / (операндите са цели числа)     |       3 / 5 == 0      |
|   Остатък при деление   |                   %                  |      11 % 2 == 1      |
|         Деление         | / (поне един от операндите е double) | (double)11 / 2 == 5.5 |
|       Степенуване       |               pow(x, n)              |     pow(3,3) == 27    |
|    Закръгляне отдолу    |               floor(x)               |    floor(5.5) == 5    |
|    Закръгляне отгоре    |                ceil(x)               |     ceil(5.5) == 6    |
|     Корен квадратен     |                sqrt(x)               |     sqrt(16) == 4     |
| Тригонометрични функции |         sin(x), cos(x), etc.         |      cos(0) == 1      |


## IV. Логически операции

|  Операция | Оператор |          Пример         |
|:---------:|:--------:|:-----------------------:|
| Конюнкция |    &&    |  true && false == false |
| Дизюнкция |   \|\|   | true \|\| false == true |

## V. Побитови операции

Двоичната бройна система е бройна система с основа 2, при която числата се изобразяват с помощта на 0 и 1.

На числото `x` в десетичната бройна система съответства `z` в двоична.

Когато трябва да обърнем число от десетична в двоична използваме следния метод:
> 1. Делим първоначалното число на 2
> 2. Ако то се дели без остатък записваме 0
> 3. Ако числото има остатък записваме 1
> 4. Връщаме се на стъпка 1., докато не достигнем 0.  

> Пример:
>|    Делене   | Остатък |
>|:-----------:|:-------:|
>| 22 / 2 = 11 |    0    |
>|  11 / 2 = 5 |    1    |
>|  5 / 2 = 2  |    1    |
>|  2 / 2 = 1  |    0    |
>|  1 / 2 = 0  |    1    |   
Остатъците се записват отдолу нагоре, т.е 10110

### Таблица на побитовите операции: 

| \| (bitwise OR)  | Взема две числа в двоичен запис и прилага операцията OR на всеки бит.                  |
|------------------|----------------------------------------------------------------------------------------|
| & (bitwise AND)  | Взема две числа в двоичен запис и прилага операцията AND на всеки бит.                 |
| ^ (bitwise XOR)  | Взема две числа в двоичен запис и прилага операцията XOR на всеки бит.                 |
| ~ (bitwise NOT)  | Взема едно число в двоичен запис и заменя всеки негов бит с противоположния му.        |
| >> (right shift) | Взема едно число в двоичен запис и премества битовете му с даден брой позиции надясно. |
| << (left shift)  | Взема едно число в двоичен запис и премества битовете му с даден брой позиции наляво.  |

## VI. Условен оператор if.

Кога използваме `if` оператора? 
> Когато искаме дадана част от програмата ни да се изпълни само ако е удовлетворено дадено условие.

### Има три вариации на `if` оператора в C++:

```c++
if (<условие>){
    <действия>;
}
// <условие> е булев израз
// <действия> е последователност от действия които искаме да се извършат ако <условие>-то е изпълнено
```

```c++
if (<условие>){
    <действия1>;
}
else{
    <действия2>;
}
// <условие> е булев израз
// <действия1> е последователност от действия които искаме да се извършат ако <условие>-то е изпълнено
// <действия2> е последователност от действия които искаме да се извършат ако <условие>-то НЕ Е изпълнено
```

```c++
if (<условие1>){
    <действия1>;
}
else if(<условие2>){
    <действия2>;
}
else if(<условиеX>...){
    <действияX>;
}
else{
    <действияN>;
}
// <условие i> е булев израз
// <действия1> е последователност от действия които искаме да се извършат ако <условие>-то е изпълнено
// <действияN> е последователност от действия които искаме да се извършат ако <условие>-то от 1 до X НЕ Е изпълнено

//В момента, в който едно от <условия>-та е изпълнено и се изпълнят съответните <действия> проверката в if-a приключва.
```

## VII. Тернарен оператор (Ternary operator)

Кога използваме тернарния оператор?

> Ако имаме една кратка операция, която искаме да се извърши в случай, че условието е изпълнено, и още една, в случай, че условието не е изпълнено.
> Често се използва, когато имаме нужда от `if - else` statement, но действията в `if` и `else`-а са кратки.
> 
> **NB** 
> 
> Тернарният оператор връща резултат, т.е можем да присвоим върнатото от него на проеменлива 
> 
> **NB**

### Синтаксис:

1. (<условие>) ? <оператор1> : <оператор2>
    - Ако условието е изпълнено се изпълнено, се изпълнява <оператор1>, ако условието НЕ Е изпълнено, се изпълнява <оператор2>.

    ```c++
    int x = 30;
    std::cout << (x == 30) ? true : false;
    // В случая ще се изпише true, защото условието е изпълнено.
    ```

2. <променлива> = (<условие>) ? <стойност1> : <стойност2>
    - Ако условието е изпълнено, на променливата се присвоява <стойност1>, ако условието НЕ е изпълнено, се присвоява <стойност2>.
    ```c++
    int x = 24;
    bool isEqualTo22 = (x == 22) ? true : false;
    std::cout << isEqualTo22; //0 (false)
    // В случая ще се изпише 0, защото условието не е изпълнено и булевата променлива приема стойност false.
    ```
## VIII. Switch оператор

Кога използваме оператора switch?

>Например когато имаме някаква променлива и предварително ни е известно точните стойности, които тя може да приема. Според тези точни стойности, може да изпълним различни действия в програмата на база, коя е стойността.

### Синтаксис: 
```c++  
switch (<израз_за_сравнение>){
    case <израз1> : <действия1>; break;
    case <израз2> : <действия2>; break;
    //... 
    case <изразN> : <действияN>; break;
    default: <действия(N+1)>;
} 
// break и default са опционални
// <израз_за_сравнение> е израза, според чиято стойност ще определим, кои случай (case-ове) ще се изпълнят
// case е запазена дума, break и default също
// <израз i> е константен израз (такъв който не съдържа променливи)
// default ще се изпълни когато стойноста на <израз_за_сравнение> не е налична в нито един от случаите case <израз i> i = 1..N
```
### А как работи оператора Switch?

1. Влизаме в Switch-a и изчисляваме стойността на <израз_за_сравнение>
2. Започва да върви ред по ред на случаите (*case*-овете). В общия случай, когато влезем в случай номер **k** case<израз**К**> се изпълнява следното:
   - Ако стойността на <израз**К**> е равна на стойността на <израз_за_сравнение> се изпълняват <действия**K**>
      - Ако накрая на <действия**К**> има `break`, изпълнението на switch-a спира.
      - Ако накрая на <действия**K**> **НЯМА** думата `break`, се изпълняват всички <действия> след **К**-тия *case* (случай) докато не се срещне думата `break`. Ако не се срещне `break` ще се изпълнят всички случай до `default`-ния (включително).
    - Ако стойността на <израз**К**> **НЕ Е** равна на стойността на <израз_за_сравнение> продължаваме към следващия *case* (случай).
3. Ако стойността на <израз_за_сравнение> не е равна на нито една от стойностите на <израз**К**> за всяко **К**, се изпълнява операторът на `default`.

```c++
int switchValue = 2;
switch(switchValue){
    case 1: std::cout << "Случай при 1. \n";
    case 2: std::cout << "Случай при 2. \n";
    default: std::cout << "Default case. \n";
}
//Изходът ще бъде:
// Случай при 2.
```

# Задачи
# Какво ще изведе програмата? Защо?
## Program 1
```c++
#include<iostream>
int main() {
    int c = 5;
    if(c += c -= 5)
        std::cout << (c *= 10);
    else
        std::cout << c;

	return 0;
}
```
## Program 2
```c++
#include<iostream>
int main() {
    int c = 5;
    std::cout << ((c == 6) || (c / 0));
	return 0;
}
```
## Program 3
```c++
#include<iostream>
int main() {
    int c = 5;
    std::cout << ((c == 5) || (c / 0));
	return 0;
}
```
## Program 4
```c++
#include<iostream>
int main() {
    int c = 5;
    std::cout << ((c == 6) && (c / 0));
	return 0;
}
```
## Program 5
```c++
#include<iostream>
int main() {
    int c = 5;
    double e = 0;
    std::cout << ((c = 6) && (e = 1)) << std::endl;
    std::cout << c << " " << e;
	return 0;
}
```
## Program 6
```c++
#include<iostream>
int main() {
    int n;
    std::cin >> n;

    std::cout << (n > 0) - (n < 0);
	return 0;
}
```
## Program 7
```c++
#include<iostream>
int main() {
    int n = 5;
    int c = (n += 10) + (n += 1);
    std::cout << c;
	return 0;
}
```

# Задачи
## Task 1
Напишете програма, в която се въвежда дължината на една отсечка в сантиметри и се извежда дължината ѝ в километри и метри.

## Task 2
Напишете програма, която въвежда едно четирицифрено число и извежда цифрите му в обратен ред, разделени с избран от Вас символ.

## Task 3
Напишете програма, която въвежда стойности на три символни променливи `ch1`, `ch2`, `ch3` със стойности измежду `0, 1, ..., 9`, като `ch1` не може да е `0` и извежда цялото число, съставено от тези цифри в последователност `ch1`, `ch2`, `ch3`. 

## Task 4
По подадено трицифрено число, изведете числото, кодирано чрез малки букви от латинската азбука по следния начин: `0 -> a, 1 -> b, 2 -> c, ...`

## Task 5*
Напишете програма, която въвежда едно трицифрено число и извежда колко пъти цифрата 7 се съдържа в него (без да използвате условен оператор или цикъл)

## Task 6
Да се напише програма, която въвежда символ и извежда съобщение на екрана дали символът е голяма буква, малка буква, цифра или друг символ.

## Task 7
Напишете програма, която въвежда две числа и разменя стойностите им чрез помощна променлива.

_Допълнително_: Разменете стойностите без променлива, използвайки само аритметични операции.

## Task 8
Напишете програма, която да приема цяло положително число (година) и да изписва на конзолата дали годината е високосна или не.

_Hint:_   
- година, деляща се на 4, е високосна;   
- ако годината също се дели на 100, то тя не е високосна;   
- но ако годината също се дели и на 400, то тя пак е високосна.

## Task 9
Напишете програма, която по въведени коефициенти `a`, `b` и `c` на уравнението `ax^2 + bx + c = 0`, пресмята неговите корени. _Забележка:_ Считаме, че входните данни са винаги такива, че уравнението има два реални корена `x1` и `x2`. 

## Task 10
Напишете програма, която намира най-голямото произведение, което може да се получи след поставянето на знак за умножение между две от цифрите на цяло положително трицифрено число.

```
Вход: 358
Изход: 280

Вход: 553
Изход: 256
```

## Task 11
Изчислете минималния покриващ правоъгълник на въведени 3 точки с целочислени координати.
Да се изведат координатите на долния ляв ъгъл на правоъгълника. 

_Забележка: В компютърната графика абсцисата се разглежда с посока отгоре-надолу._

```
Вход: 41 67     34 69      24 78
Изход: 24 67
```
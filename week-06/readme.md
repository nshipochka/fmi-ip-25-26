# Какво ще изведе кодът?
### 1
```c++
int a = 5;
int& b = a;
    
int* pa = &a;
int* pb = &b;

std::cout << pa << " " << pb; 
```

### 2
```c++
void f(int* arr) {
	std::cout <<"arr = " << arr << ", *arr = " 
		<< *arr << ", arr[0] = " << arr[0] << std::endl;
}

int main() {
	int arr[] = { 1,2,3 };
	f(arr);

	return 0;
}
```

### 3
```c++
void f(int arr[]) {
	std::cout << "arr = " << arr << ", *arr = " 
		<< *arr << ", arr[0] = " << arr[0] << std::endl;
}

int main() {
	int arr[] = { 1,2,3 };
	f(arr);

	return 0;
}
```

### 4
```c++
void f1(int* arr) {
	std::cout << sizeof(arr) / sizeof(int) << std::endl;
}

void f2(int arr[]) {
	std::cout << sizeof(arr) / sizeof(int) << std::endl;
}

int main() {
	int arr[] = { 1,2,3 };
	std::cout << sizeof(arr) / sizeof(int) << std::endl;

	f1(arr);
	f2(arr);

	return 0;
}
```

### 5
```c++
int arr[] = { 1,2,3 };

std::cout << *(arr + 1);
std::cout << *(arr + 4);
```

### 6
```c++
int arr[4] = { 1,2,3 };
std::cout << arr[3];
```

### 7
```c++
int arr[4] = { 1,2,3, };
std::cout << arr[3];
```

### 8
```c++
int arr[] = { 1,2,3, };
std::cout << arr[3];
```

# Сортиране и търсене
## Сортиране
### Bubble Sort
Многократно обхождаме списъка, сравняваме съседни елементи и ги разменяме, ако са в грешен ред. По-големите елементи постепенно "изплуват" до края на масива, както мехурчета във.

#### Алгоритъм (нарастващ ред):

1. Започваме от началото на масива.

2. Сравняваме всеки съседен чифт елементи.

3. Ако елементите са в грешен ред, разменяме ги.

4. Повтаряме, докато не се направи цяло обхождане без нито една размяна.

#### Имплементация

```c++

#include <iostream
#include <algoritm> // За std::swap

void bubbleSort(int arr[], size_t size) {    
    // Обхожда всички елементи на масива
    for (int i = 0; i < size - 1; i++) {
        bool swapped = false;
        
        // Последните i елемента вече са на мястото си, затова обхождаме до size - i - 1
        for (int j = 0; j < size - i - 1; j++) {
            // Сравнява съседни елементи
            if (arr[j] > arr[j + 1]) {
                // Разменя ги
                std::swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        
        // Ако не е направена размяна в обхода, масивът е сортиран
        if (swapped == false)
            break;
    }
}
```
### Selection Sort

Mногократно намираме най-малкия елемент от несортираната част и го поставяме на първата позиция на несортираната част (т.е., в края на сортираната част).

#### Алгоритъм (нарастващ ред):

1. Започваме от първия елемент.

2. Намираме индекса на най-малкия елемент в несортирания остатък на масива.

3. Разменяме най-малкия елемент с елемента на текущата позиция (i).

4. Повтаряме процеса за следващата позиция.

#### Имплементация

```c++
#inclde <algorithm> // За std::swap

void selectionSort(int arr[], size_t size) {
    // Преминава през целия масив
    for (int i = 0; i < size - 1; i++) {
        // Предполагаме, че текущият елемент е най-малкият
        int min_idx = i;
        
        // Търси най-малкия елемент в остатъка arr[i+1...n-1]
        for (int j = i + 1; j < size; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        
        // Разменя намерения минимален елемент с елемента на текущата позиция i
        if (min_idx != i) {
            std::swap(arr[i], arr[min_idx]);
        }
    }
}
```

### Insertion Sort

Изграждаме сортирания масив елемент по елемент, както като играем на карти. На всяка итерация вземаме елемент от несортираната част и го вмъкваме на правилното му място в сортираната част (вляво).

#### Алгоритъм (нарастващ ред):

1. Започваме от втория елемент (`i = 1`).

2. Вземаме текущия елемент (`key`).

3. Сравняваме `key` с елементите в сортираната част.

4. Местим всички по-големи елементи с една позиция надясно.

5. Вмъкваме `key` на освободеното място.

#### Имплементация

```c++
void insertionSort(int arr[], size_t size) {
    // Започва от втория елемент (индекс 1)
    for (int i = 1; i < size; i++) {
        int key = arr[i]; // Елементът, който трябва да вмъкнем
        int j = i - 1;
        
        // Премества елементите arr[0..i-1], които са по-големи от key, 
        // с една позиция надясно, за да освободи място
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        
        // Вмъква key на правилната позиция
        arr[j + 1] = key;
    }
}
```
## Търсене
### Последователно/Линейно търсене

Започваме от началото на списъка и проверяваме всеки елемент един по един, докато не се намери търсената стойност или докато не се стигне до края.

#### Алгоритъм:

1. Обхождаме масива от началото до края.

2. Сравняваме текущия елемент с търсения елемент.

3. Ако съвпадат, връщаме индекса.

4. Ако стигнем края, връщаме стойност, сигнализираща, че не е намерен търсеният елемент (например, -1).

#### Имплементация

```c++
// Връща индекса на елемента, или -1 ако не е намерен
int sequentialSearch(int arr[], size_t size, int target) {
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            return i; // Връща индекса
        }
    }
    return -1; // Не е намерен
}
```

### Binary Search (Двоично Търсене)

Алгоритъмът работи, като многократно разделя интервала за търсене наполовина. **Важно: Binary Search работи само върху сортирани масиви или списъци!**

#### Алгоритъм:

1. Определяме началото (`low`) и края (`high`) на масива.

2. Изчисляваме средната точка (`mid`).

3. Сравняваме търсената стойност (`target`) с `arr[mid]`.

4. Ако съвпадат, връщаме `mid` (индекса, на който е намерен елемента).

5. Ако е по-малък от `mid`: Търсенето продължава в лявата половина.

6. Ако е по-голям от `mid`: Търсенето продължава в дясната половина.

```c++
// Връща индекса на елемента, или -1 ако не е намерен
int binarySearch(const int arr[], size_t size, int target) {
    int low = 0;
    int high = size - 1;
    
    while (low <= high) {
        // Изчислява средния индекс
        int mid = low + (high - low) / 2; // Избягва препълване при много големи индекси
        
        if (arr[mid] == target) {
            return mid; // Намерен
        }
        
        // Ако target е по-голям, игнорира лявата половина
        else if (arr[mid] < target) {
            low = mid + 1;
        }
        
        // Ако target е по-малък, игнорира дясната половина
        else {
            high = mid - 1;
        }
    }
    
    return -1; // Не е намерен
}
```